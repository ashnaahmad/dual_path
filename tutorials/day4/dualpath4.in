# what-where model lens 2.3.1

addNet dualPath -i 30

## these are the input layers
set semSize 45
set lexSize 45 
set eventsemSize 10
set whereSize 10

## hidden layers 
set hiddenSize 20
set contextSize $hiddenSize
set compressSize 10
set ccompressSize 10

seed 100

## create layers
addGroup cword $lexSize ELMAN ELMAN_CLAMP ELMAN_CLAMP -BIASED OUT_NORM
addGroup ccompress $ccompressSize -BIASED 
addGroup cwhat $semSize OUTPUT TARGET_COPY -BIASED -WRITE_OUTPUTS
addGroup cwhere2 $whereSize ELMAN ELMAN_CLAMP ELMAN_CLAMP -BIASED  
addGroup cwhere $whereSize SOFT_MAX -BIASED 
addGroup eventsem $eventsemSize LINEAR -BIASED
addGroup context $contextSize ELMAN OUT_INTEGR -BIASED 
addGroup hidden $hiddenSize -BIASED 
addGroup where $whereSize -BIASED
addGroup what $semSize -BIASED
addGroup compress $compressSize -BIASED 
addGroup targ $lexSize INPUT 
addGroup word $lexSize OUTPUT SOFT_MAX STANDARD_CRIT USE_OUTPUT_HIST USE_TARGET_HIST -BIASED 

## parameters for connections
## hystersis 1=copy  0=no change  
setObj context.dtScale 1 

## connect layers
connectGroups cword cwhat -type cwordcwhat
connectGroups cwhat cwhere -type ww
connectGroups where what -type ww
connectGroups what word -type whatword
connectGroups hidden where -type hidwhere 
connectGroups context hidden -type conthid
connectGroups cwhere hidden -type prehid
connectGroups cwhere2 hidden -type prehid
connectGroups eventsem hidden -type esemhid
connectGroups hidden compress word -type hidword
connectGroups cword ccompress hidden -type cwordhid

## connect bias
connectGroups bias eventsem -type bt
connectGroups bias what -type low
connectGroups bias cwhat -type low

## copy output of what units as training signal for cwhat units
copyConnect what cwhat outputs

## create elman unit connections and initial states
elmanConnect targ cword -r 1 -init 0.0
elmanConnect word cword -r 1 -init 0.0
elmanConnect cwhere cwhere2 -r 1 -init 0.0
elmanConnect cwhere2 cwhere2 -r 1 -init 0.0
elmanConnect hidden context -r 1 -init 0.5

## turn off learning for what-where cwhat-cwhere message weights
setLinkValue learningRate 0 -t ww
setLinkValues randMean  0 -t ww
setLinkValues randRange 0 -t ww

## turn off learning for event-semantic weights
setLinkValue learningRate 0 -t bt
setLinkValues randMean  0 -t bt
setLinkValues randRange 0 -t bt

## set bias of what units so that normal activation is low
setLinkValue learningRate 0 -t low
setLinkValues randMean  -3 -t low
setLinkValues randRange 0 -t low

## seed and randomize network
randWeights -t low
freezeWeight -t low


setObj numUpdates 2000

setObj learningRate 0.1
set strength 6 
set reducer 0.5
set treduce 0.5
set inittlink 0.5
set inittargtlink 0.5

loadExamples traine.ex
loadExamples testprode.ex
loadExamples trainj.ex
loadExamples testprodj.ex

proc clear {} {
    randWeights -t ww
    randWeights -t bt
}
clear

proc link {input args} {
    global strength
    foreach j $args {
        setObj what.unit($j).incoming($input).weight $strength;
	setObj cwhere.unit($input).incoming($j).weight $strength;
    }
}

proc tlink {args} {
    global reducer
    global inittlink

    set tstrength $inittlink
    set randlevel [randInt 2]
    foreach j $args {
	if {$j < 0} {    	 
	    set tstrength [expr $tstrength * $reducer]
	} else {
	    setObj eventsem.unit($j).incoming(0).weight $tstrength;
 	}
    }
}

proc saveTest {time {label ""} {numpats 0}} {
     set filename $time$label
     if {[file isdirectory results] == 0} { file mkdir results}
     if {[file isfile results/res$filename.out.gz] == 1} { set filename $filename.1 }

     openNetOutputFile results/res$filename.out
     test $numpats
     closeNetOutputFile
     exec gzip -f results/res$filename.out
     exec decode9.perl results/res$filename.out.gz | syncode.perl > sum$filename & 
}

proc useSaveTest {time set {numpats 0}} {
    useTestingSet $set
    exampleSetMode $set ORDERED
    saveTest $time $set $numpats
}

setObj batchSize 1
setObj numUpdates 1000
setObj reportInterval 500
resetNet

proc trainSave {{lang ""} {max 10}} {
  resetNet
  set numEpochs 1000
  loadExamples train$lang.ex
  loadExamples testprod$lang.ex

  for {set iepoch 0} {$iepoch < $max } {incr iepoch} {
      useTrainingSet train$lang
      exampleSetMode train$lang PERMUTED
      train $numEpochs

      set epo [getObj totalUpdates]
      saveWeights comp$epo.wt.gz

      ## only test 1000 train patterns      
      useSaveTest $epo train$lang 1000
      useSaveTest $epo testprod$lang

      set wtfile comp$epo.wt.gz
      loadWeights $wtfile

      puts [exec date]
  }
}

if {[file isdirectory results] == 0} { file mkdir results}

proc loadfile {command filename} {
   if {[file isfile $filename]} { $command $filename }
   if {[file isfile results/$filename]} { $command results/$filename }
}

proc testone {time set} {
    loadfile "loadWeight" comp$time.wt.gz
    useSaveTest $time $set
}

proc setlabels {layer args} {
  set c 0
  foreach n $args {
    setObj $layer.unit($c).name $n
    incr c 1
  }
}

setlabels word - the a man woman cat dog boy girl father mother sister brother nurse teacher ball stick toy kite sleep jump walk run push hit kick carry give throw show present glorp is are was were by that to . -par -ing -s -ed being
setlabels cword - the a man woman cat dog boy girl father mother sister brother nurse teacher ball stick toy kite sleep jump walk run push hit kick carry give throw show present glorp is are was were by that to . -par -ing -s -ed being
setlabels what - THE A MAN WOMAN CAT DOG BOY GIRL FATHER MOTHER SISTER BROTHER NURSE TEACHER BALL STICK TOY KITE SLEEP JUMP WALK RUN PUSH HIT KICK CARRY GIVE THROW SHOW PRESENT GLORP
setlabels cwhat - THE A MAN WOMAN CAT DOG BOY GIRL FATHER MOTHER SISTER BROTHER NURSE TEACHER BALL STICK TOY KITE SLEEP JUMP WALK RUN PUSH HIT KICK CARRY GIVE THROW SHOW PRESENT GLORP
setlabels where A X Y Z B C
setlabels cwhere A X Y Z B C
setlabels eventsem PRES PAST SIMP PROG XX YY ZZ CC DD